<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Eco-Scan Audio Tool</title>
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  
  <style>
    body { margin: 0; overflow: hidden; background: #000; font-family: 'Inter', sans-serif; color: #fff; }
    canvas { display: block; }
    
    /* Scrollbar styling for the controls */
    ::-webkit-scrollbar { width: 4px; height: 4px; }
    ::-webkit-scrollbar-track { background: #111; }
    ::-webkit-scrollbar-thumb { background: #444; border-radius: 2px; }
    ::-webkit-scrollbar-thumb:hover { background: #666; }

    /* Horizontal scrollbar for presets */
    .preset-scroll::-webkit-scrollbar { height: 2px; }
    .preset-scroll::-webkit-scrollbar-track { background: #111; }
    .preset-scroll::-webkit-scrollbar-thumb { background: #444; }

    select { appearance: none; -webkit-appearance: none; border-radius: 0; }
    
    @keyframes pulse {
        0% { opacity: 1; }
        50% { opacity: 0.5; }
        100% { opacity: 1; }
    }
  </style>

  <!-- Babel for browser-based JSX compilation -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>

  <!-- Main Application Code -->
  <script type="text/babel" data-type="module">
    import React, { useState, useEffect, useRef, useCallback } from 'https://esm.sh/react@18.2.0';
    import { createRoot } from 'https://esm.sh/react-dom@18.2.0/client';

    // -----------------------------------------------------------------------------
    // Data & Constants
    // -----------------------------------------------------------------------------

    // Minor Pentatonic Scale
    const SCALE_FREQUENCIES = [
      130.81, 155.56, 174.61, 196.00, 233.08, // C3
      261.63, 311.13, 349.23, 392.00, 466.16, // C4
      523.25, 622.25, 698.46, 783.99, 932.33, // C5
      1046.50, 1244.50, 1396.91, 1567.98 // C6
    ].reverse();

    const GRID_COLS = 16;
    const GRID_ROWS = 12;
    const MAX_VOICES_PER_FRAME = 12; 

    const INSTRUMENTS = [
      { label: 'ANALOG SYNTH', value: 'synth' },
      { label: 'ELECTRIC PIANO', value: 'epiano' },
      { label: 'CYBER PLUCK', value: 'pluck' },
      { label: 'DEEP BASS', value: 'bass' },
      { label: 'MARIMBA', value: 'marimba' },
      { label: 'XYLOPHONE', value: 'xylophone' },
      { label: 'FM BELLS', value: 'bells' },
      { label: 'GLITCH NOISE', value: 'glitch' },
      { label: 'RHYTHM GRID', value: 'drums' },
    ];

    const INITIAL_PRESETS = [
      { id: 'v1', label: 'BIRDS', filename: 'https://github.com/seanpeoples-collab/nature-sonification/blob/main/Birds.mp4', type: 'factory' },
      { id: 'v2', label: 'LIGHTNING', filename: 'https://github.com/seanpeoples-collab/nature-sonification/blob/main/Lightning.mp4', type: 'factory' },
      { id: 'v3', label: 'LEAVES', filename: 'https://github.com/seanpeoples-collab/nature-sonification/blob/main/Leaves.mp4', type: 'factory' },
      { id: 'v4', label: 'LAVA', filename: 'https://github.com/seanpeoples-collab/nature-sonification/blob/main/Lava.mp4', type: 'factory' },
      { id: 'v5', label: 'DRIZZLING', filename: 'https://github.com/seanpeoples-collab/nature-sonification/blob/main/Drizzling.mp4', type: 'factory' },
      { id: 'v6', label: 'PUDDLE', filename: 'https://github.com/seanpeoples-collab/nature-sonification/blob/main/Puddle.mp4', type: 'factory' },
    ];

    // -----------------------------------------------------------------------------
    // Audio Engine
    // -----------------------------------------------------------------------------

    class AudioEngine {
      constructor() {
        this.ctx = null;
        this.masterGain = null;
        this.compressor = null;
        this.filterNode = null;
        this.distortionNode = null;
        this.reverbNode = null;
        this.reverbGain = null;
        this.delayNode = null;
        this.delayFeedbackGain = null;
        this.delayOutputGain = null;
        this.noiseBuffer = null;
        this.currentInstrument = 'bells'; 
        this.driftAmount = 0; // New parameter for "Harmonic Drift"
      }

      init() {
        if (this.ctx) {
            if (this.ctx.state === 'suspended') {
                this.ctx.resume().catch(() => {});
            }
            return;
        }
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.4;

        // Master Chain
        this.distortionNode = this.ctx.createWaveShaper();
        this.distortionNode.curve = this.makeDistortionCurve(0);
        this.distortionNode.oversample = '4x';

        this.filterNode = this.ctx.createBiquadFilter();
        this.filterNode.type = 'lowpass';
        this.filterNode.frequency.value = 20000;
        this.filterNode.Q.value = 1;

        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -20;
        this.compressor.ratio.value = 12;

        this.masterGain.connect(this.distortionNode);
        this.distortionNode.connect(this.filterNode);
        this.filterNode.connect(this.compressor);
        this.compressor.connect(this.ctx.destination);

        // Reverb
        this.reverbNode = this.ctx.createConvolver();
        this.reverbGain = this.ctx.createGain();
        this.reverbGain.gain.value = 0.4;
        this.generateImpulse();
        
        this.reverbNode.connect(this.reverbGain);
        this.reverbGain.connect(this.masterGain);

        // Delay
        this.delayNode = this.ctx.createDelay(5.0);
        this.delayNode.delayTime.value = 0.3;
        this.delayFeedbackGain = this.ctx.createGain();
        this.delayFeedbackGain.gain.value = 0.3;
        this.delayOutputGain = this.ctx.createGain();
        this.delayOutputGain.gain.value = 0.3;

        this.delayNode.connect(this.delayOutputGain);
        this.delayOutputGain.connect(this.masterGain);
        this.delayNode.connect(this.delayFeedbackGain);
        this.delayFeedbackGain.connect(this.delayNode);

        // Noise Buffer
        const rate = this.ctx.sampleRate;
        const noiseLen = rate * 2;
        this.noiseBuffer = this.ctx.createBuffer(1, noiseLen, rate);
        const output = this.noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseLen; i++) {
          output[i] = Math.random() * 2 - 1;
        }
      }

      generateImpulse() {
         if(!this.ctx) return;
         const rate = this.ctx.sampleRate;
         const length = rate * 3.0;
         const impulse = this.ctx.createBuffer(2, length, rate);
         const left = impulse.getChannelData(0);
         const right = impulse.getChannelData(1);
         for (let i = 0; i < length; i++) {
           const n = i / length;
           const white = (Math.random() * 2 - 1);
           left[i] = white * Math.pow(1 - n, 3.0);
           right[i] = white * Math.pow(1 - n, 3.0);
         }
         this.reverbNode.buffer = impulse;
      }

      makeDistortionCurve(amount) {
        const k = amount * 100;
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
          const x = (i * 2) / n_samples - 1;
          curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
      }

      setDrift(val) { this.driftAmount = val; }
      setInstrument(inst) { this.currentInstrument = inst; }
      
      setReverbMix(value) { if (this.reverbGain && this.ctx) this.reverbGain.gain.setTargetAtTime(value, this.ctx.currentTime, 0.1); }
      setDelayTime(value) { if (this.delayNode && this.ctx) this.delayNode.delayTime.setTargetAtTime(0.05 + value * 0.95, this.ctx.currentTime, 0.1); }
      setDelayFeedback(value) { if (this.delayFeedbackGain && this.ctx) this.delayFeedbackGain.gain.setTargetAtTime(value * 0.9, this.ctx.currentTime, 0.1); }
      setFilterFreq(value) { if (this.filterNode && this.ctx) this.filterNode.frequency.setTargetAtTime(40 * Math.pow(20000 / 40, value), this.ctx.currentTime, 0.1); }
      setDistortion(value) { if (this.distortionNode) this.distortionNode.curve = this.makeDistortionCurve(value * 4); }

      // Helper to apply Drift (detune)
      applyDrift(osc, now) {
         if (this.driftAmount > 0.01) {
             const detune = (Math.random() * 2 - 1) * (this.driftAmount * 100); // +/- cents
             osc.detune.setValueAtTime(detune, now);
             // Slow LFO effect via ramp
             osc.detune.linearRampToValueAtTime((Math.random() * 2 - 1) * (this.driftAmount * 100), now + 0.5);
         }
      }

      trigger(row, col, intensity) {
        if (!this.ctx || !this.masterGain) return;
        if (this.ctx.state === 'suspended') return;

        const pan = (col / GRID_COLS) * 2 - 1;
        const now = this.ctx.currentTime;
        
        const panner = this.ctx.createStereoPanner();
        panner.pan.value = pan;
        panner.connect(this.masterGain);
        
        if (this.reverbNode && this.delayNode) {
            panner.connect(this.reverbNode);
            panner.connect(this.delayNode);
        }

        if (this.currentInstrument === 'drums') {
            this.playDrum(row, intensity, now, panner);
        } else {
            this.playMelodic(row, intensity, now, panner);
        }
      }

      playDrum(row, intensity, now, dest) {
        if (!this.ctx || !this.noiseBuffer) return;
        const gain = this.ctx.createGain();
        gain.connect(dest);

        // Simple drum mapping logic
        if (row < 4) { // Hi-Hat
            const src = this.ctx.createBufferSource();
            src.buffer = this.noiseBuffer;
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'highpass'; filter.frequency.value = 8000;
            src.connect(filter); filter.connect(gain);
            gain.gain.setValueAtTime(intensity * 0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
            src.start(now); src.stop(now + 0.2);
        } else if (row < 8) { // Snare-ish
            const noiseSrc = this.ctx.createBufferSource();
            noiseSrc.buffer = this.noiseBuffer;
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'bandpass'; filter.frequency.value = 1500;
            noiseSrc.connect(filter); filter.connect(gain);
            gain.gain.setValueAtTime(intensity * 0.5, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
            noiseSrc.start(now); noiseSrc.stop(now + 0.2);
        } else { // Kick
            const osc = this.ctx.createOscillator();
            osc.frequency.setValueAtTime(100, now);
            osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
            osc.connect(gain);
            gain.gain.setValueAtTime(intensity * 0.8, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
            osc.start(now); osc.stop(now + 0.4);
        }
      }

      playMelodic(row, intensity, now, dest) {
          if (!this.ctx) return;
          const scaleIndex = Math.floor((row / GRID_ROWS) * SCALE_FREQUENCIES.length);
          const frequency = SCALE_FREQUENCIES[Math.min(scaleIndex, SCALE_FREQUENCIES.length - 1)];
          const gain = this.ctx.createGain();
          gain.connect(dest);

          // Simple Synthesizer Mapping
          if (this.currentInstrument === 'marimba' || this.currentInstrument === 'xylophone' || this.currentInstrument === 'bells') {
              // Sine based
              const osc = this.ctx.createOscillator();
              osc.type = 'sine';
              osc.frequency.value = frequency;
              this.applyDrift(osc, now);
              
              if(this.currentInstrument === 'bells') {
                  // FM
                  const mod = this.ctx.createOscillator();
                  const modG = this.ctx.createGain();
                  mod.frequency.value = frequency * 2.4;
                  modG.gain.value = frequency;
                  mod.connect(modG); modG.connect(osc.frequency);
                  mod.start(now); mod.stop(now+1);
              }

              osc.connect(gain);
              gain.gain.setValueAtTime(0, now);
              gain.gain.linearRampToValueAtTime(intensity * 0.5, now + 0.01);
              gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
              osc.start(now); osc.stop(now + 0.6);

          } else if (this.currentInstrument === 'pluck' || this.currentInstrument === 'bass') {
              // Sawtooth based
              const osc = this.ctx.createOscillator();
              osc.type = 'sawtooth';
              osc.frequency.value = this.currentInstrument === 'bass' ? frequency * 0.5 : frequency;
              this.applyDrift(osc, now);

              const filter = this.ctx.createBiquadFilter();
              filter.type = 'lowpass';
              osc.connect(filter); filter.connect(gain);
              
              filter.frequency.setValueAtTime(frequency, now);
              filter.frequency.exponentialRampToValueAtTime(frequency * 4, now + 0.05);
              filter.frequency.exponentialRampToValueAtTime(frequency, now + 0.3);

              gain.gain.setValueAtTime(0, now);
              gain.gain.linearRampToValueAtTime(intensity * 0.4, now + 0.01);
              gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
              osc.start(now); osc.stop(now + 0.5);
          } else {
              // Standard Synth
              const osc = this.ctx.createOscillator();
              osc.type = 'triangle';
              osc.frequency.value = frequency;
              this.applyDrift(osc, now);
              osc.connect(gain);
              gain.gain.setValueAtTime(0, now);
              gain.gain.linearRampToValueAtTime(intensity * 0.4, now + 0.02);
              gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
              osc.start(now); osc.stop(now + 0.4);
          }
      }
    }

    const audioEngine = new AudioEngine();

    // -----------------------------------------------------------------------------
    // App Logic
    // -----------------------------------------------------------------------------

    const processVideoUrl = (url) => {
        let finalUrl = url.trim();
        if (finalUrl.includes('dropbox.com')) {
            const base = finalUrl.split('?')[0];
            finalUrl = base.includes('/scl/fi/') 
                ? `${base}?rlkey=${(finalUrl.match(/rlkey=([a-zA-Z0-9]+)/) || [])[1]}&raw=1` 
                : `${base}?raw=1`;
        } else if (finalUrl.includes('drive.google.com')) {
            const idMatch = finalUrl.match(/\/d\/([a-zA-Z0-9_-]+)/);
            if (idMatch) finalUrl = `https://drive.google.com/uc?export=download&id=${idMatch[1]}`;
        } else if (finalUrl.includes('github.com')) {
            finalUrl = finalUrl.replace(/^(https?:\/\/)(www\.)?github\.com/, '$1raw.githubusercontent.com').replace('/blob/', '/');
        }
        return finalUrl;
    };

    const App = () => {
      // Core State
      const [isPlaying, setIsPlaying] = useState(false);
      const [hasStarted, setHasStarted] = useState(false);
      const [videoSrc, setVideoSrc] = useState(null);
      const [streamUrl, setStreamUrl] = useState('');
      const [loadErrorMsg, setLoadErrorMsg] = useState(null);
      const [corsMode, setCorsMode] = useState("anonymous");
      const [isVisualOnly, setIsVisualOnly] = useState(false);
      const [audioSuspended, setAudioSuspended] = useState(false);
      
      // UI State
      const [showControls, setShowControls] = useState(true);
      const [showEmbedModal, setShowEmbedModal] = useState(false);
      
      // Parameters
      const [playbackSpeed, setPlaybackSpeed] = useState(1.0);
      const [sensitivity, setSensitivity] = useState(0.5); 
      const [instrument, setInstrumentState] = useState('bells');
      
      // Generative FX
      const [chaosLevel, setChaosLevel] = useState(0.0);
      const [harmonicDrift, setHarmonicDriftState] = useState(0.0);

      // Audio FX
      const [reverbMix, setReverbMix] = useState(0.4);
      const [delayTime, setDelayTimeState] = useState(0.3);
      const [delayFeedback, setDelayFeedbackState] = useState(0.4);
      const [filterFreq, setFilterFreqState] = useState(1.0);
      const [distortion, setDistortionState] = useState(0.0);
      
      // Presets
      const [presets, setPresets] = useState(INITIAL_PRESETS);
      
      // Refs
      const canvasRef = useRef(null);
      const videoRef = useRef(null);
      const analysisCanvasRef = useRef(null);
      const requestRef = useRef(null);
      const fileInputRef = useRef(null);
      const gridRef = useRef([]);
      const prevFrameDataRef = useRef(null);
      
      // Init Grid
      useEffect(() => {
        const cells = [];
        for(let r=0; r<GRID_ROWS; r++) {
          for(let c=0; c<GRID_COLS; c++) {
            cells.push({ x: c, y: r, active: 0, cooldown: 0 });
          }
        }
        gridRef.current = cells;
      }, []);

      // Auto-load (Modified for V2.5 - Do NOT auto-play)
      useEffect(() => {
        if (!videoSrc && INITIAL_PRESETS[0].filename) {
             const video = INITIAL_PRESETS[0];
             setVideoSrc(processVideoUrl(video.filename));
             // We do NOT trigger play here. We wait for user interaction.
        }
      }, []);

      // Audio Monitoring
      useEffect(() => {
        const interval = setInterval(() => {
            setAudioSuspended(audioEngine.ctx && audioEngine.ctx.state === 'suspended');
        }, 500);
        return () => clearInterval(interval);
      }, []);

      // Param Sync
      useEffect(() => { audioEngine.setReverbMix(reverbMix); }, [reverbMix]);
      useEffect(() => { audioEngine.setDelayTime(delayTime); }, [delayTime]);
      useEffect(() => { audioEngine.setDelayFeedback(delayFeedback); }, [delayFeedback]);
      useEffect(() => { audioEngine.setFilterFreq(filterFreq); }, [filterFreq]);
      useEffect(() => { audioEngine.setDistortion(distortion); }, [distortion]);
      useEffect(() => { audioEngine.setInstrument(instrument); }, [instrument]);
      useEffect(() => { audioEngine.setDrift(harmonicDrift); }, [harmonicDrift]);
      useEffect(() => { if (videoRef.current) videoRef.current.playbackRate = playbackSpeed; }, [playbackSpeed]);

      const togglePlay = () => {
        if (!hasStarted) setHasStarted(true);
        audioEngine.init();
        if (!isPlaying) {
          if (videoRef.current && videoSrc) videoRef.current.play().catch(console.error);
        } else {
          if (videoRef.current) videoRef.current.pause();
        }
        setIsPlaying(!isPlaying);
      };

      const handlePresetClick = (video) => {
          setHasStarted(true);
          audioEngine.init();
          if (!video.filename) return;
          setIsPlaying(false);
          setCorsMode("anonymous");
          setIsVisualOnly(false);
          setLoadErrorMsg(null);
          prevFrameDataRef.current = null;
          setVideoSrc(processVideoUrl(video.filename));
          setTimeout(() => { if (videoRef.current) { videoRef.current.play().catch(()=>{}); setIsPlaying(true); }}, 100);
      };

      const handleCustomUpload = (e) => {
        setHasStarted(true);
        audioEngine.init();
        if (e.target.files && e.target.files[0]) {
          const url = URL.createObjectURL(e.target.files[0]);
          setVideoSrc(url);
          setLoadErrorMsg(null);
          setCorsMode(undefined); 
          setIsVisualOnly(false);
          setIsPlaying(false);
          prevFrameDataRef.current = null;
          setTimeout(() => { if (videoRef.current) { videoRef.current.play().catch(()=>{}); setIsPlaying(true); }}, 200);
        }
      };

      const handleStreamSubmit = () => {
          setHasStarted(true);
          audioEngine.init();
          if (!streamUrl) return;
          setVideoSrc(processVideoUrl(streamUrl));
          setLoadErrorMsg(null);
          setCorsMode("anonymous");
          setIsVisualOnly(false);
          setIsPlaying(false);
          prevFrameDataRef.current = null;
          setTimeout(() => { if (videoRef.current) { videoRef.current.play().catch(()=>{}); setIsPlaying(true); }}, 200);
      };

      const handleVideoError = (e) => {
          if (corsMode === "anonymous") {
              setCorsMode(undefined);
              setIsVisualOnly(true);
              return;
          }
          setLoadErrorMsg("SIGNAL FAILED. CHECK FILE PERMISSIONS.");
          setIsPlaying(false);
          setVideoSrc(null); 
      };

      useEffect(() => {
        const animate = () => {
          const canvas = canvasRef.current;
          const video = videoRef.current;

          if (canvas) {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            if (canvas.width !== rect.width * dpr || canvas.height !== rect.height * dpr) {
              canvas.width = rect.width * dpr;
              canvas.height = rect.height * dpr;
            }

            const ctx = canvas.getContext('2d');
            if (ctx) {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.save();
              ctx.scale(dpr, dpr);
              
              if (isPlaying && video && !video.paused && !video.ended && !loadErrorMsg && !isVisualOnly) {
                analyzeMotion(video, rect.width, rect.height);
              }
              drawActiveCells(ctx, rect.width, rect.height);
              ctx.restore();
            }
          }
          requestRef.current = requestAnimationFrame(animate);
        };

        const analyzeMotion = (video, displayW, displayH) => {
          if (!analysisCanvasRef.current) {
            analysisCanvasRef.current = document.createElement('canvas');
            analysisCanvasRef.current.width = GRID_COLS;
            analysisCanvasRef.current.height = GRID_ROWS;
          }
          
          const aCtx = analysisCanvasRef.current.getContext('2d', { willReadFrequently: true });
          if (!aCtx) return;

          try {
            aCtx.drawImage(video, 0, 0, GRID_COLS, GRID_ROWS);
            const frameData = aCtx.getImageData(0, 0, GRID_COLS, GRID_ROWS).data;
            
            if (prevFrameDataRef.current) {
                const threshold = (1.0 - sensitivity) * 100;
                const triggers = [];
                
                for (let i = 0; i < gridRef.current.length; i++) {
                    const cell = gridRef.current[i];
                    
                    if (chaosLevel > 0 && Math.random() < (chaosLevel * 0.005)) {
                        triggers.push({ idx: i, intensity: Math.random() * 0.8 + 0.2 });
                        cell.active = 1.0;
                        cell.cooldown = 10;
                        continue; 
                    }

                    const rIdx = (i * 4);
                    const rDiff = Math.abs(frameData[rIdx] - prevFrameDataRef.current[rIdx]);
                    const gDiff = Math.abs(frameData[rIdx+1] - prevFrameDataRef.current[rIdx+1]);
                    const bDiff = Math.abs(frameData[rIdx+2] - prevFrameDataRef.current[rIdx+2]);
                    const totalDiff = (rDiff + gDiff + bDiff) / 3;

                    if (cell.cooldown > 0) {
                        cell.cooldown--;
                        cell.active *= 0.9; 
                    } else if (totalDiff > threshold) {
                        const intensity = Math.min(1, totalDiff / 255 * 4);
                        cell.active = 1.0;
                        cell.cooldown = 10;
                        triggers.push({ idx: i, intensity });
                    } else {
                        cell.active *= 0.8;
                    }
                }
                
                if (triggers.length > 0) {
                    triggers.sort((a, b) => b.intensity - a.intensity);
                    const voiceCount = Math.min(triggers.length, MAX_VOICES_PER_FRAME);
                    for(let k = 0; k < voiceCount; k++) {
                        const t = triggers[k];
                        const cell = gridRef.current[t.idx];
                        audioEngine.trigger(cell.y, cell.x, t.intensity);
                    }
                }
            }
            prevFrameDataRef.current = Uint8ClampedArray.from(frameData);
          } catch (e) { 
              console.error(e);
              setIsVisualOnly(true);
          }
        };

        const drawActiveCells = (ctx, w, h) => {
          const cellW = w / GRID_COLS;
          const cellH = h / GRID_ROWS;
          gridRef.current.forEach(cell => {
            if (cell.active > 0.01) {
              const x = cell.x * cellW;
              const y = cell.y * cellH;
              
              ctx.fillStyle = `rgba(255, 255, 255, ${cell.active * 0.3})`;
              ctx.fillRect(x + 1, y + 1, cellW - 2, cellH - 2);
              
              ctx.strokeStyle = `rgba(255, 255, 255, ${cell.active})`;
              ctx.lineWidth = 1;
              ctx.strokeRect(x + 4, y + 4, cellW - 8, cellH - 8);
            }
          });
        };

        requestRef.current = requestAnimationFrame(animate);
        return () => { if (requestRef.current !== null) cancelAnimationFrame(requestRef.current); };
      }, [isPlaying, sensitivity, loadErrorMsg, isVisualOnly, chaosLevel]); 

      return (
        <div style={{ display: 'flex', flexDirection: 'column', height: '100vh', background: '#111', color: '#fff' }}>
          
          {/* HEADER BAR */}
          <div style={{
              height: '40px', background: '#000', borderBottom: '1px solid #222', 
              display: 'flex', alignItems: 'center', justifyContent: 'space-between', padding: '0 1rem',
              zIndex: 50, flexShrink: 0
          }}>
             <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
                <span style={{ fontWeight: 600, fontSize: '12px', letterSpacing: '1px' }}>TERRA TONES</span>
                <span style={{ fontSize: '9px', color: '#666', border: '1px solid #333', padding: '1px 3px' }}>V2.5</span>
             </div>
             <div style={{ display: 'flex', gap: '1rem' }}>
                <button 
                    onClick={() => setShowControls(!showControls)} 
                    style={{ background: 'transparent', border: 'none', color: '#fff', fontSize: '10px', cursor: 'pointer', fontFamily: 'JetBrains Mono, monospace' }}
                >
                    {showControls ? '[ HIDE INTERFACE ]' : '[ SHOW INTERFACE ]'}
                </button>
                <button 
                    onClick={() => setShowEmbedModal(true)} 
                    style={{ background: '#fff', border: 'none', color: '#000', fontSize: '10px', cursor: 'pointer', padding: '2px 6px', fontWeight: 600 }}
                >
                    EMBED
                </button>
             </div>
          </div>

          {/* TOP DASHBOARD (SIGNAL BANK + PARAMETERS) */}
          {showControls && (
            <div style={{ 
                background: '#0a0a0a', borderBottom: '1px solid #222', padding: '12px 1rem', 
                zIndex: 40, flexShrink: 0, maxHeight: '50vh', overflowY: 'auto'
            }}>
                {/* SIGNAL BANK (PRESETS) */}
                <div style={{ marginBottom: '16px' }}>
                    <div style={{ fontSize: '9px', color: '#666', marginBottom: '8px', letterSpacing: '1px', display: 'flex', justifyContent: 'space-between' }}>
                         <span>SIGNAL BANK</span>
                    </div>
                    <div className="preset-scroll" style={{ display: 'flex', gap: '8px', overflowX: 'auto', paddingBottom: '8px' }}>
                        
                        {presets.map(p => (
                            <button key={p.id} onClick={() => handlePresetClick(p)} 
                                style={{ 
                                    padding: '8px 12px', 
                                    background: (videoSrc === p.filename) ? '#fff' : '#111', 
                                    color: (videoSrc === p.filename) ? '#000' : '#888',
                                    border: '1px solid #333',
                                    cursor: 'pointer', fontSize: '10px', whiteSpace: 'nowrap', minWidth: '80px', textAlign: 'center'
                                }}
                            >
                                {p.label}
                            </button>
                        ))}

                        <button onClick={() => fileInputRef.current?.click()} 
                            style={{ 
                                padding: '8px 12px', 
                                background: '#222', 
                                color: '#fff',
                                border: '1px solid #444',
                                cursor: 'pointer', fontSize: '10px', whiteSpace: 'nowrap', minWidth: '80px', textAlign: 'center', fontWeight: 600
                            }}
                        >
                            [ ↑ UPLOAD ]
                        </button>
                    </div>
                </div>

                {/* MAIN PARAMETERS GRID */}
                <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(140px, 1fr))', gap: '1.5rem', alignItems: 'end' }}>
                    <div>
                        <label style={{ display: 'block', fontSize: '9px', color: '#666', marginBottom: '6px', letterSpacing: '0.5px' }}>INSTRUMENT</label>
                        <select value={instrument} onChange={e => setInstrumentState(e.target.value)} 
                            style={{ width: '100%', padding: '6px', background: '#111', color: '#ddd', border: '1px solid #333', fontSize: '11px', fontFamily: 'JetBrains Mono' }}>
                            {INSTRUMENTS.map(i => <option key={i.value} value={i.value}>{i.label}</option>)}
                        </select>
                    </div>
                    
                    <SliderCompact label="SENSITIVITY" value={sensitivity} onChange={setSensitivity} display={`${Math.round(sensitivity*100)}%`} />
                    <SliderCompact label="SPEED" value={(playbackSpeed-0.1)/1.9} onChange={v => setPlaybackSpeed(0.1 + v*1.9)} display={`${playbackSpeed.toFixed(1)}x`} />
                    
                    <div style={{ display: 'flex' }}>
                         <button onClick={togglePlay} 
                            style={{ 
                                width: '100%', padding: '8px', fontSize: '10px', letterSpacing: '1px', cursor: 'pointer',
                                background: isPlaying ? '#ddd' : '#222', color: isPlaying ? '#000' : '#888', border: '1px solid #444', fontWeight: isPlaying ? 600 : 400 
                            }}>
                            {isPlaying ? '[ ⏸ PAUSE SCAN ]' : '[ ▶ START SCAN ]'}
                        </button>
                    </div>
                </div>
            </div>
          )}

          {/* MAIN CANVAS AREA */}
          <div style={{ flex: 1, position: 'relative', overflow: 'hidden', background: '#050505' }}>
             <input type="file" ref={fileInputRef} accept="video/*" style={{ display: 'none' }} onChange={handleCustomUpload} />
             
             {videoSrc && (
                <video ref={videoRef} src={videoSrc} muted loop playsInline crossOrigin={corsMode} onError={handleVideoError}
                style={{ position: 'absolute', width: '100%', height: '100%', objectFit: 'cover', opacity: 0.6, display: loadErrorMsg ? 'none' : 'block' }} />
             )}
             
             <canvas ref={canvasRef} style={{ position: 'absolute', width: '100%', height: '100%' }} />

             {/* INITIAL START OVERLAY */}
             {!hasStarted && !loadErrorMsg && videoSrc && (
                 <div 
                    onClick={() => {
                        setHasStarted(true);
                        togglePlay();
                    }}
                    style={{ 
                        position: 'absolute', inset: 0, zIndex: 60,
                        display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center',
                        background: 'rgba(0,0,0,0.6)', cursor: 'pointer', backdropFilter: 'blur(2px)'
                    }}
                 >
                    <div style={{ 
                        border: '1px solid #fff', padding: '20px 40px', background: '#000', color: '#fff', 
                        letterSpacing: '2px', fontSize: '12px', textAlign: 'center', boxShadow: '0 0 20px rgba(0,0,0,0.5)'
                    }}>
                        [ INITIALIZE SYSTEM ]
                    </div>
                 </div>
             )}

             {(!videoSrc || loadErrorMsg) && (
                 <div style={{ position: 'absolute', inset: 0, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', background: '#111' }}>
                    <div style={{ border: '1px solid #333', padding: '2rem', textAlign: 'center', maxWidth: '400px' }}>
                        <h2 style={{ fontSize: '14px', marginBottom: '1rem', color: '#fff', letterSpacing: '1px' }}>NO SIGNAL</h2>
                        {loadErrorMsg ? <p style={{color: '#f55', fontSize: '11px'}}>{loadErrorMsg}</p> : <p style={{color: '#666', fontSize: '11px'}}>Select a signal source to begin.</p>}
                        <div style={{ display: 'flex', flexDirection: 'column', gap: '8px', marginTop: '1rem' }}>
                            <button onClick={() => fileInputRef.current?.click()} style={{ padding: '8px', background: '#222', color: '#fff', border: '1px solid #444', cursor: 'pointer', fontSize: '10px' }}>UPLOAD FILE</button>
                            <div style={{ display: 'flex', gap: '5px' }}>
                                <input type="text" placeholder="Paste URL..." value={streamUrl} onChange={e=>setStreamUrl(e.target.value)} style={{ flex: 1, background: '#000', border: '1px solid #333', color: '#fff', padding: '4px', fontSize: '10px' }}/>
                                <button onClick={handleStreamSubmit} style={{ padding: '4px 8px', background: '#fff', color: '#000', border: 'none', cursor: 'pointer', fontSize: '10px' }}>GO</button>
                            </div>
                        </div>
                    </div>
                 </div>
             )}

            {hasStarted && videoSrc && audioSuspended && !loadErrorMsg && (
                <div onClick={togglePlay} style={{ position: 'absolute', bottom: '20px', left: '50%', transform: 'translateX(-50%)', background: '#f00', color: '#fff', padding: '5px 10px', fontSize: '10px', cursor: 'pointer', zIndex: 50 }}>
                    AUDIO OFF - CLICK TO START
                </div>
            )}
          </div>

          {/* BOTTOM DASHBOARD (FX ONLY) */}
          {showControls && (
            <div style={{ 
                height: 'auto', maxHeight: '35vh', background: '#0a0a0a', borderTop: '1px solid #222', 
                zIndex: 40, flexShrink: 0, display: 'flex', flexDirection: 'column'
            }}>
                <div style={{ padding: '1rem', overflowY: 'auto' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '12px', borderBottom: '1px solid #222', paddingBottom: '8px' }}>
                        <span style={{ fontSize: '10px', color: '#fff', letterSpacing: '1px' }}>AUDIO PROCESSOR</span>
                    </div>

                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '2rem' }}>
                        <div>
                            <h4 style={{ margin: '0 0 12px 0', fontSize: '10px', color: '#666', letterSpacing: '1px' }}>GENERATIVE</h4>
                            <SliderCompact label="BIO-CHAOS" value={chaosLevel} onChange={setChaosLevel} display={`${Math.round(chaosLevel*100)}%`} />
                            <SliderCompact label="HARMONIC DRIFT" value={harmonicDrift} onChange={setHarmonicDriftState} display={`${Math.round(harmonicDrift*100)}%`} />
                        </div>
                        <div>
                            <h4 style={{ margin: '0 0 12px 0', fontSize: '10px', color: '#666', letterSpacing: '1px' }}>EFFECTS CHAIN</h4>
                            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1rem' }}>
                                <SliderCompact label="REVERB" value={reverbMix} onChange={setReverbMix} display={`${Math.round(reverbMix*100)}%`} />
                                <SliderCompact label="DELAY" value={delayTime} onChange={setDelayTimeState} display={`${Math.round(delayTime*100)}%`} />
                                <SliderCompact label="FILTER" value={filterFreq} onChange={setFilterFreqState} display={`${Math.round(filterFreq*100)}%`} />
                                <SliderCompact label="DISTORT" value={distortion} onChange={setDistortionState} display={`${Math.round(distortion*100)}%`} />
                            </div>
                        </div>
                    </div>
                </div>
            </div>
          )}

          {/* EMBED MODAL */}
          {showEmbedModal && (
            <div style={{ position: 'absolute', inset: 0, background: 'rgba(0,0,0,0.9)', zIndex: 100, display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
                <div style={{ background: '#fff', color: '#000', padding: '2rem', maxWidth: '500px', width: '90%' }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '1rem' }}>
                        <h2 style={{ fontSize: '14px', margin: 0 }}>EMBED CODE</h2>
                        <button onClick={() => setShowEmbedModal(false)} style={{ background: 'transparent', border: 'none', fontSize: '16px', cursor: 'pointer' }}>✕</button>
                    </div>
                    <p style={{ fontSize: '12px', color: '#666', marginBottom: '1rem' }}>For Squarespace/Wix, use a "Code Block" and paste this:</p>
                    <textarea readOnly style={{ width: '100%', height: '80px', background: '#f5f5f5', border: '1px solid #ddd', padding: '10px', fontSize: '11px', fontFamily: 'monospace' }}
                        value={`<iframe src="${window.location.href}" width="100%" height="800" frameborder="0" allow="autoplay; microphone" allowfullscreen style="display: block; width: 100%;"></iframe>`}
                    />
                </div>
            </div>
          )}

        </div>
      );
    };

    // Compact Slider with increased vertical spacing to prevent text overlap
    const SliderCompact = ({ label, value, onChange, display }) => (
        <div style={{ marginBottom: '8px' }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '9px', marginBottom: '6px', color: '#666' }}>
                <span>{label}</span>
                <span>{display}</span>
            </div>
            <input type="range" min="0" max="1" step="0.01" value={value} onChange={e => onChange(parseFloat(e.target.value))} 
                   style={{ width: '100%', accentColor: '#fff', height: '2px', background: '#333', appearance: 'none', cursor: 'pointer', display: 'block' }} />
        </div>
    );

    const container = document.getElementById('root');
    const root = createRoot(container);
    root.render(<App />);
  </script>
</body>
</html>
